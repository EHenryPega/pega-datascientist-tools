---
title: "`r params$title`"
author: "Pega CDH Tools"
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
    toc: yes
  pdf_document: default
always_allow_html: true
params:
  title:
    value: "Example pxDR Decision Results Analysis"
    
  source:
    # Full path to pxDR dataset export zip
    # value: "~/Downloads/Data-Decision-Results_pxDecisionResults_20220112T162055_GMT.zip"
    # value: "~/Downloads/Data-Decision-Results_pxDecisionResults_20220117T123506_GMT.zip"
    # value: "~/Downloads/Data-Decision-Results_pxDecisionResults_20220117T134919_GMT.zip"
    
    # baseline, before bug fix
    # value: "~/Downloads/Data-Decision-Results_pxDecisionResults_20220128T162345_GMT.zip"

    # with bug fixes
    # value: "~/Downloads/Data-Decision-Results_pxDecisionResults_20220128T163121_GMT.zip"
    value: "~/Downloads/Data-Decision-Results_pxDecisionResults_20220201T085415_GMT.zip"
    
    
  topNpropositions:
    value: 40
    
  topNinteractions:
    value: 10

  topNdecisions:
    value: 15
    
  indexOfSelectedInteraction:
    value: 1

---

```{r, echo=F, warning=F, error=F, include=FALSE}
library(cdhtools)

# include below when developing the library
# sapply(list.files("~/Documents/pega/cdh-datascientist-tools/r/R", "*.R", full.names = T), source)

library(data.table)
library(lubridate)
library(ggplot2)
library(colorspace)
library(scales)
library(knitr)
library(kableExtra)
library(bit64)

theme_set(theme_light())
```

# Intro

Detailed analysis of the **pxDR** decision results with a focus on the 
"Model Execution Results". Strategy Results are the outputs of 
a strategy. 

For analysis purposes you would typically first truncate
it, run a data flow for just a limited number of interactions, then 
export the **pxDecisionResults** dataset.


# Load data

Read the data. pxDR is a nested structure so making sure to include embedded
complex types.

```{r}
pxDR <- readDSExport(params$source, excludeComplexTypes = F)
pxDR[["pxUpdateDateTime"]] <- as.integer64(pxDR$pxUpdateDateTime)
dim(pxDR)
```

# Showing the first `r params$params$topNdecisions` decision results for all `r length(pxDR)` interactions

```{r}
splitModelExecutionReferences <- function(mrefs)
{
  sapply(strsplit(mrefs,",",fixed=T),as.integer)  
}

countStringModelExecutionReferences <- function(mrefs)
{
  ifelse(sapply(mrefs, is.na), 0L,
         sapply(strsplit(mrefs,",",fixed=T),length))  
}

decisionResults <- rbindlist(pxDR$pxDecisionResults, fill = T)[, c("pyOutcome", "pyPropensity", "pyName", "pyChannel", 
                                                                   "pzModelExecutionReferences", "pyModelPropensity", 
                                                                   "pxDecisionTime", "pxInteractionID")]

cdhtools::standardizeFieldCasing(decisionResults)

decisionResults[, pxDRindex := unlist(sapply(seq(nrow(pxDR)), function(i){rep(i, nrow(pxDR$pxDecisionResults[[i]]))}))]
decisionResults[, nMERs := countStringModelExecutionReferences(Modelexecutionreferences) ]

decisionResults[order(DecisionTime)] %>% head(params$topNdecisions) %>% kbl() %>% kable_paper("hover", full_width = T)
```

## Proposition Distribution

Showing the tope `r params$topNpropositions` propositions.

```{r}
propositionDistributionSummary <- 
  decisionResults[, .(N=.N), by=c("Name", "Channel")]
propositionDistributionSummary[, Total := sum(N), by=Name]
propositionDistributionSummary[, Rank := rank(Total)]
setorder(propositionDistributionSummary, -Rank)
propositionDistributionSummary[, Name := factor(Name, unique(Name))]

ggplot(propositionDistributionSummary[as.integer(Name)<=params$topNpropositions], aes(Name, N, fill=Channel)) + geom_col() +
  theme(axis.text.x = element_text(angle = 90, hjust = 0)) +
  scale_fill_discrete_qualitative() +
  ggtitle("Number of Propositions", subtitle = paste("top", params$topNpropositions))
```

## Totals across all `r length(pxDR)` interactions

```{r}
pxDR[, nDecisionResults := sapply(pxDecisionResults, nrow)]
pxDR[, nModelExecutionResults := sapply(pxModelExecutionResults, nrow)]

data.table( Interactions = nrow(pxDR),
            DecisionResults = sum(pxDR$nDecisionResults),
            ModelExecutionResults = sum(pxDR$nModelExecutionResults)) %>% 
  kbl() %>% kable_paper("hover", full_width = T)
```

## Number of Decision Results and Model Executions for the first `r params$topNinteractions` interactions

Showing the first couple of records along with the number of decision 
results and the total number of unique model execution results.

```{r}
pxDR[, c("pxVersion", "pxInteractionID", "pxSubjectID", "nDecisionResults", "nModelExecutionResults", "pxUpdateDateTime")][order(pxUpdateDateTime)] %>% head(params$topNinteractions) %>% 
  kbl() %>% kable_paper("hover", full_width = T)
```

## Decision Results split by Outcome for all decisions

Decision results and model executions split by outcome. In addition showing
which decision results have no propensity attached.


```{r}

decisionResults[, .(`Decision Results` = .N, 
                    `Decision Results w/o Model Propensities` = sum(is.na(Modelpropensity)),
                    `Decision Results w/o Propensities` = sum(is.na(Propensity)),
                    `Model Execution Results` = 
                      sum(countStringModelExecutionReferences(Modelexecutionreferences))),
                by="Outcome"][order(-`Model Execution Results`)] %>% 
  kbl() %>% kable_paper("hover", full_width = T)
```

## Decision Results split by Outcome for all decisions

Decision results and model executions split by outcome.

Strategy results typically have only a few model executions, depending on 
the configuration of course. A single model has one, a simple prediction two,
a two-stage prediction 5 and if there are additional models involved in 
evaluating a prediction, more.

```{r}

plt <- ggplot(decisionResults, aes(as.factor(nMERs), fill=Outcome)) + 
  geom_bar() +
  ggtitle("Total Number of Model Execution Results by Outcome") +
  scale_fill_discrete_qualitative() +
  xlab("Model Execution Results") 
# +scale_y_continuous(limits=c(0,2000))

plotly::ggplotly(plt)
```

## Decision Results by Channel and Outcome

Showing the number of decision results for each channel and outcome combination,
also highlighting the number of decision results w/o a propensity.

Which propositions do not have outcomes depends on the customer attributes.

```{r}
ggplot(decisionResults[, .(N = .N, NoPropensity = sum(is.na(Modelpropensity))), by=c("Channel", "Outcome")], 
       aes(Outcome, Channel, label=paste(N, NoPropensity, sep="/"))) + 
  geom_raster(fill="lightgrey") +
  geom_text(size=3) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Decision results by Channel and Outcome")
```

# Types of Model execution results for all interactions

```{r}
modelExecutionDetailsFromJSON <- function(modelExecutionJSON) 
{
  if (is.na(modelExecutionJSON) || length(modelExecutionJSON)==0) {
    return(data.table(modelType = NA,
                      component = NA,
                      positives = NA,
                      negatives = NA,
                      rule = NA))
  }
  mer_list <- jsonlite::fromJSON(modelExecutionJSON)
  return(data.table(modelType = mer_list[["modelType"]],
                    component = mer_list[["component"]],
                    positives = paste(unlist(mer_list[["positiveOutcomes"]]), collapse = "/"),
                    negatives = paste(unlist(mer_list[["negativeOutcomes"]]), collapse = "/"),
                    rule = paste(mer_list[["ruleClass"]], mer_list[["ruleName"]], sep = ":")))  
}

modelExecutionSummary <- rbindlist(lapply(seq(nrow(decisionResults)),
                                          function(i) {
                                            merJSONs <- as.data.table(pxDR[decisionResults[i, pxDRindex]]$pxModelExecutionResults[[1]])
                                            
                                            results <- rbindlist(lapply(merJSONs[splitModelExecutionReferences(decisionResults[i, Modelexecutionreferences]),]$pxModelExecutionResults, 
                                                                        modelExecutionDetailsFromJSON), 
                                                                 use.names = T, fill = T)
                                            
                                            results[, Outcome := decisionResults[i, Outcome]]
                                            results
                                          } ), use.names = T, fill = T)

dcast(modelExecutionSummary, modelType+component+positives+negatives+rule ~ Outcome, fun.aggregate = length) %>%
  kbl() %>% kable_paper("hover", full_width = T)
```

# Analysis of one specific interaction

Analyzing one specific interaction. One interaction is usually for one
customer.

```{r}
interactionID <- pxDR[params$indexOfSelectedInteraction]$pxInteractionID
# modelExecutionResults <- as.data.table(pxDR[params$indexOfSelectedInteraction]$pxModelExecutionResults[[1]])


interactionID
```

## Model execution results for one decision result of interaction `r interactionID`

Picking one that has many model references.

```{r}
modelExecutionReferences <- splitModelExecutionReferences(decisionResults[interactionID==InteractionID, Modelexecutionreferences])
srOfInterest <- which.max(sapply(modelExecutionReferences, length))

modelExecutionReferences[[srOfInterest]]
```

## List of Model Execution Results for one SR

Lookup the model execution result data for SR `r srOfInterest`

```{r}
# pxDR belonging to selected decision result
pxDRIndex <- decisionResults[interactionID==InteractionID][srOfInterest, pxDRindex]

# JSON representations of all MERS of this interaction
merJSONs <- as.data.table(pxDR[pxDRIndex]$pxModelExecutionResults[[1]])

rbindlist(lapply(merJSONs[modelExecutionReferences[[srOfInterest]],]$pxModelExecutionResults, 
                                                                        modelExecutionDetailsFromJSON), 
                                                                 use.names = T, fill = T) %>% 
  kbl() %>% kable_paper("hover", full_width = T)
```

## Raw JSON for the same Model Execution Results

```{r}
x <- sapply(merJSONs[modelExecutionReferences[[srOfInterest]],]$pxModelExecutionResults, function(x){ cat(fill=T); cat(jsonlite::minify(x), fill=T)})


```


