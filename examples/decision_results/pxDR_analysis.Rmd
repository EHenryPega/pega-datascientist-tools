---
title: "`r params$title`"
author: "Pega CDH Tools"
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
    toc: yes
  pdf_document: default
always_allow_html: true
params:
  title:
    value: "Example pxDR Decision Results Analysis"
    
  source:
    # Full path to pxDR dataset export zip
    #value: "~/Downloads/Data-Decision-Results_pxDecisionResults_20220112T162055_GMT.zip"
    #value: "~/Downloads/Data-Decision-Results_pxDecisionResults_20220117T123506_GMT.zip"
    value: "~/Downloads/Data-Decision-Results_pxDecisionResults_20220117T134919_GMT.zip"
---

```{r, echo=F, warning=F, error=F, include=FALSE}
library(cdhtools)

# include below when developing the library
# sapply(list.files("~/Documents/pega/cdh-datascientist-tools/r/R", "*.R", full.names = T), source)

library(data.table)
library(lubridate)
library(ggplot2)
library(colorspace)
library(scales)
library(knitr)
library(kableExtra)

theme_set(theme_light())
```

# Intro

Detailed analysis of the **pxDR** decision results with a focus on the 
"Model Execution Results". Strategy Results are the outputs of 
a strategy. 

For analysis purposes you would typically first truncate
it, run a data flow for just a limited number of interactions, then 
export the **pxDecisionResults** dataset.


# Load data

Read the data. pxDR is a nested structure so making sure to include embedded
complex types.

```{r}
pxDR <- readDSExport(params$source, excludeComplexTypes = F)
dim(pxDR)
```

# Overview of all decision results

## Simple histogram of top actions


```{r}
propositionDistribution <- data.table(
  Name = unlist(sapply(pxDR$pxDecisionResults, function(x) { x$pyName } )),
  Group = unlist(sapply(pxDR$pxDecisionResults, function(x) { x$pyGroup } )),
  Issue = unlist(sapply(pxDR$pxDecisionResults, function(x) { x$pyIssue } )),
  Channel = unlist(sapply(pxDR$pxDecisionResults, function(x) { x$pyChannel } )))

propositionDistributionSummary <- 
  propositionDistribution[, .(N=.N), by=c("Name", "Channel")]
propositionDistributionSummary[, Total := sum(N), by=Name]
propositionDistributionSummary[, Rank := rank(Total)]
setorder(propositionDistributionSummary, -Rank)
propositionDistributionSummary[, Name := factor(Name, unique(Name))]

ggplot(propositionDistributionSummary[as.integer(Name)<40], aes(Name, N, fill=Channel)) + geom_col() +
  theme(axis.text.x = element_text(angle = 90, hjust = 0)) +
  scale_fill_discrete_qualitative() +
  ggtitle("Number of Propositions", subtitle = "top 40")
```

## Totals for first records

Showing the first couple of records along with the number of decision 
results and the total number of unique model execution results.

```{r}
pxDR[, nDecisionResults := sapply(pxDecisionResults, nrow)]
pxDR[, nModelExecutionResults := sapply(pxModelExecutionResults, nrow)]

pxDR[, c("pxVersion", "pxInteractionID", "pxSubjectID", "nDecisionResults", "nModelExecutionResults")] %>% head(10) %>% kbl() %>% kable_paper("hover", full_width = T)
```

## Totals

```{r}
data.table( Interactions = nrow(pxDR),
            DecisionResults = sum(pxDR$nDecisionResults),
            ModelExecutionResults = sum(pxDR$nModelExecutionResults)) %>% kbl() %>% kable_paper("hover", full_width = T)
```


# One interaction

Analyzing one specific interaction

```{r}
interaction <- pxDR[1]
```



```{r}
decisionResults <- as.data.table(interaction$pxDecisionResults[[1]]) # pzModelExecutionReferences inside
modelExecutionResults <- as.data.table(interaction$pxModelExecutionResults[[1]])
modelExecutionReferences <- lapply(strsplit(decisionResults$pzModelExecutionReferences,",",fixed = T), as.numeric)
```

## Interaction `r interaction$pxInteractionID` (`r interaction$pxSubjectID`) split by Outcome

Decision results and model executions split by outcome

```{r}
decisionResults[, .(`Decision Results` = .N, 
                    `Decision Results w/o Propensities` = sum(is.na(pyModelPropensity)),
                    `Model Execution Results` = 
                      sum(ifelse(sapply(pzModelExecutionReferences, is.na), 0L,
                                 sapply(strsplit(pzModelExecutionReferences,",",fixed=T),length)))),
                by="pyOutcome"][order(-`Decision Results`)] %>% 
  kbl() %>% kable_paper("hover", full_width = T)
```

## Proposition x outcomes

```{r}
ggplot(decisionResults[, .(.N), by=c("pxIdentifier", "pyOutcome")], aes(pyOutcome, pxIdentifier, label=N)) + 
  geom_raster(fill="lightgrey") +
  geom_text(size=2) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), axis.text.y = element_text(size=5)) +
  ggtitle("Decision results by Proposition and Outcome", subtitle = paste(unique(decisionResults$pySubjectID), collapse = ", "))
```

# Model execution results for all decision results of one interaction

```{r}
ggplot(data.table(mers = as.factor(sapply(modelExecutionReferences, length)),
                  outcome = decisionResults$pyOutcome), aes(mers, fill=outcome)) + 
  geom_bar() +
  ggtitle("Number of Model Execution Results", 
          subtitle = paste("for", uniqueN(decisionResults$pxInteractionID), "interaction")) +
  scale_fill_discrete_qualitative() +
  xlab("Model Execution Results")
```


```{r}
singleModelExecutionResultSummary <- function(mer) 
{
  if (is.na(mer) || length(mer)==0) {
    return(data.table(modelType = NA,
                    component = NA,
                    positives = NA,
                    negatives = NA,
                    rule = NA))
  }
  mer_list <- jsonlite::fromJSON(mer)
  return(data.table(modelType = mer_list[["modelType"]],
                    component = mer_list[["component"]],
                    positives = paste(unlist(mer_list[["positiveOutcomes"]]), collapse = "/"),
                    negatives = paste(unlist(mer_list[["negativeOutcomes"]]), collapse = "/"),
                    rule = paste(mer_list[["ruleClass"]], mer_list[["ruleName"]], sep = ":")))  
}

multipleModelExecutionResultSummary <- function(refs)
{
  rbindlist(lapply(modelExecutionResults[refs,]$pxModelExecutionResults, singleModelExecutionResultSummary), 
            use.names = T, fill = T)  
}


modelExecutionSummaryForOneInteraction <- rbindlist(lapply(seq(nrow(decisionResults)), 
                                                    function(i) { 
                                                      results <- multipleModelExecutionResultSummary(modelExecutionReferences[[i]])
                                                      results[, pyOutcome := decisionResults[i, pyOutcome]]
                                                      results
                                                    } ), use.names = T, fill = T)

modelExecutionSummaryForOneInteractionOverview <- modelExecutionSummaryForOneInteraction[, .(nModelExecutionResults = .N), 
                                       by=c("modelType", "component", "rule", "pyOutcome")][order(-nModelExecutionResults)]

dcast(modelExecutionSummaryForOneInteractionOverview, modelType+component+rule ~ pyOutcome, value.var = "nModelExecutionResults", fill=0) %>% 
  kbl() %>% kable_paper("hover", full_width = T)
```



# Model execution results for one decision result


```{r}
srOfInterest <- which.max(sapply(modelExecutionReferences, length))

modelExecutionReferences[[srOfInterest]]
```

# List of Model Execution Results for one particular SR

Lookup the model execution result data for SR `r srOfInterest`

```{r}
multipleModelExecutionResultSummary(modelExecutionReferences[[srOfInterest]]) %>% 
  kbl() %>% kable_paper("hover", full_width = T)
```


